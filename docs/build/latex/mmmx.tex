%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Ensemble structure}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{MMMx}
\date{Aug 03, 2020}
\release{}
\author{Gunnar Jeschke}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\begin{sphinxadmonition}{warning}{Warning:}
MMMx is at an early design and prototyping stage. Version 0.0.0 is not functional.
\end{sphinxadmonition}
\begin{itemize}
\item {} 
MMMx is the successor program of MMM (Multiscale Modeling of Macromolecules)

\item {} 
Graphical user interface is separated from computation modules

\item {} 
Methods can be implemented in any language. They communicate by a few defined data exchange formats

\end{itemize}


\chapter{Functional entity}
\label{\detokenize{functional_entity:functional-entity}}\label{\detokenize{functional_entity::doc}}

\section{The object of interest}
\label{\detokenize{functional_entity:the-object-of-interest}}
Structural biology is about macromolecules, such as proteins and nucleic acids, and their complexes with other macromolecules or small ligands.

Such an object is a functional biological entity, as is assembled for fulfilling a certain task in a cell. In MMMx, we briefly call it \sphinxstyleemphasis{entity}.

Only very rarely, entities have structures, where each atom position is defined on a length scale corresponding to a typical bond length. Such high order would conflict with the dynamic nature of their function.

Usually, an entity is disordered to different extent on different levels of structural hierarchy and along the sequence of a macromolecular chain.

Description of the structure of an entity must take this into account. This requires an ensemble description.


\section{Structural hierarchy}
\label{\detokenize{functional_entity:structural-hierarchy}}
An entity has several levels of structure
\begin{itemize}
\item {} \begin{description}
\item[{Primary structure}] \leavevmode
Primary structure is fixed within an entity
\begin{itemize}
\item {} 
chemical structure of each individual component

\item {} 
defines topology of the structure

\item {} 
has no explicit relation to three\sphinxhyphen{}dimensional structure

\item {} 
fixes some aspects of three\sphinxhyphen{}dimensional structure with high precision (bond lengths and bond angles)

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Secondary structure}] \leavevmode
Local conformation of a molecule
\begin{itemize}
\item {} 
often used as a synonym for the presence of secondary structure elements, such as helices and strands

\item {} 
the term is somewhat loose: three\sphinxhyphen{}dimensional form of \sphinxstyleemphasis{local segments} of proteins

\item {} 
there are two contributions: local backbone conformation and sidechain rotamers

\item {} 
sidechain rotamers are not usually understood as secondary structure

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Tertiary structure}] \leavevmode
Global conformation of a single molecule
\begin{itemize}
\item {} 
overall three\sphinxhyphen{}dimensional arrangement of a polypeptide or polynucleotide chain

\item {} 
conformation of small\sphinxhyphen{}molecule ligands is analogous, but not usually considered as tertiary structure

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Quaternary structure}] \leavevmode
Number and arrangement of the components of a complex
\begin{itemize}
\item {} 
while the number of components my be variable, we keep it fixed for an entity

\item {} 
different relative arrangements of subunits are usually related to different teriary structure of the subunits

\end{itemize}

\end{description}

\end{itemize}


\bigskip\hrule\bigskip


This hierarchy is useful for understanding some aspects of structure, but not necessarily for representing structure of an entity or analyzing all its aspects.


\chapter{Structure representation}
\label{\detokenize{structure_representation:structure-representation}}\label{\detokenize{structure_representation::doc}}

\section{Protein database (PDB) format}
\label{\detokenize{structure_representation:protein-database-pdb-format}}
Structural biology has inherited structure representation from protein crystallography with one addition from NMR structure determination.

The main aspects of this representation are:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
Three\sphinxhyphen{}dimensional structure is defined by Cartesian atom coordinates in units of Angstroem

\item {} 
Uncertainty about structure is quantified by isotropic or anisotropic distribution of atom positions (B factors) for crystal structures.
For NMR structures, it is represented by presenting several models (typically 20).

\item {} 
Genuine disorder is represented by alternate atom locations with associated populations or missing atoms in crystal structures.
In NMR structures, genuine disorder contributes to structure variation between models and is generally indistinguishable from uncertainty.

\end{enumerate}

In the end, this boils down to \(n_{\mathrm{coor},k}\) coordinate specifications \((x_k,y_k,z_k)\) for atom \(k\) of the entity, where
\begin{equation*}
\begin{split}n_{\mathrm{coor},k} = \sum_{m = 1}^M \sum_{l = 1}^{L_{k,m}} 1\end{split}
\end{equation*}
where \(M\) is the number of models and \(L_{k,m}\) is the number of alternate locations of atom \(k\) in model \(m\).

Whereas the alternate locations have associated populations \(p_{l,m}\) with \(\sum_{l = 1}^{L_{k,m}} p_{l,m} = 1\), all models are assumed to be equally populated.

This format is supported by virtually all software packages for structural biology and will not vanish. MMMx can read and write it.
It is not a suitable representation for the structure of entities with functionally relevant disorder.


\section{PDBx/mmCIF format}
\label{\detokenize{structure_representation:pdbx-mmcif-format}}
This format \sphinxhref{http://mmcif.wwpdb.org/docs/faqs/pdbx-mmcif-faq-general.html}{has formally replaced the PDB format at protein database in 2014}. It allows for much more annotation, is nicely extensible, and less strict on line formatting.

It does not differ from the PDB format with respect to structure representation.


\section{MMMx internal representations}
\label{\detokenize{structure_representation:mmmx-internal-representations}}
As a multi\sphinxhyphen{}scale modeller, MMMx needs extensible and varied representations of entity structure. Two representations exist in the first release:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
{\hyperref[\detokenize{MMMx_atomic:mmmx-atomic}]{\sphinxcrossref{\DUrole{std,std-ref}{MMMx|atomic}}}}: This representation is closest to PDB representation, but allows for non\sphinxhyphen{}uniform conformer populations and sidegroup rotamers with associated populations. Rotamers overrule atom locations.

\item {} 
{\hyperref[\detokenize{MMMx_RigiFlex:mmmx-rigiflex}]{\sphinxcrossref{\DUrole{std,std-ref}{MMMx|RigiFlex}}}}: This representation keeps full information on rigid\sphinxhyphen{}body arrangement for models where some chains or chain segments are specified as rigid bodies.
It is also more memory economic for such models, which can matter for large ensembles.

\end{enumerate}

All MMMx internal representations can be converted to the PDB representation, although with some loss of information or large inflation of file size and memory requirements.

Conversion of representations can be sequential.
For instance, the \sphinxcode{\sphinxupquote{MMMx|RigiFlex}} representation is first expanded to the \sphinxcode{\sphinxupquote{MMMx|atomic}} representation and then projected onto the PDB representation:
\begin{equation*}
\begin{split}\mathrm{MMMx}|\mathrm{RigiFlex} \rightarrow \mathrm{MMMx}|\mathrm{atomic} \rightarrow \mathrm{PDB}\end{split}
\end{equation*}
In this sequence, \sphinxcode{\sphinxupquote{RigiFlex}} presents the highest level of description (most information) and \sphinxcode{\sphinxupquote{PDB}} the lowest. Backwards conversion is not usually possible.
Internally, MMMx represents structure on the highest possible level.

It follows that ChimeraX holds the master copy of an entity structure only if the structure originally came from a PDB file or can be represented in PDB without loss of information.
Otherwise, MMMx holds the master copy.


\chapter{Selection by address}
\label{\detokenize{MMMx_addresses:selection-by-address}}\label{\detokenize{MMMx_addresses:mmmx-addresses}}\label{\detokenize{MMMx_addresses::doc}}

\section{Topology and ensemble addressing}
\label{\detokenize{MMMx_addresses:topology-and-ensemble-addressing}}
Addresses are used for selecting part of an entity (see {\hyperref[\detokenize{MMMx_atomic:mmmx-atomic}]{\sphinxcrossref{\DUrole{std,std-ref}{MMMx|atomic}}}}) for display, processing, or analysis.
Such selection can refer to objects in the molecular structure (chains or molecules in a complex, residues, atoms) or to different realizations of an object (conformers of the whole structure, sidechain rotamers, atom locations).
The first selection type is \sphinxstyleemphasis{topology addressing}  and the second selection type \sphinxstyleemphasis{ensemble addressing}.

MMMx internally uses only one index for atom locations (old style) and rotamers (new style).
Since atom locations in crystal structure cannot generally and umabigously assigned to rotamers, addressing allows reference to either locations or rotamers in a given structure.
Mixing both concepts is discouraged, but the address style and selection functions do not prevent it.
MMMx stores occupation of water atoms from the PDB file, but does not allow to select water locations by address.


\section{Chains}
\label{\detokenize{MMMx_addresses:chains}}
Chain identifiers should be upper\sphinxhyphen{}case letters for up to 26 chains and lower\sphinxhyphen{}case letters for chains 27\sphinxhyphen{}52 chains. Chain identifiers longer than on letter are not compatible with PDB format, but are allowed in MMMx if required.
Chain identifiers in MMMx must start with a letter and must not contain an underscore \sphinxcode{\sphinxupquote{\_}}. Chain addresses are enclosed in parentheses (\sphinxstyleemphasis{chain}).

\begin{sphinxadmonition}{note}{Chain address examples}

\sphinxcode{\sphinxupquote{(C)}}  addresses chain C

\sphinxcode{\sphinxupquote{(A,C,g)}} addresses chains A, C, and g

\sphinxcode{\sphinxupquote{(*)}} addresses all chains
\end{sphinxadmonition}


\section{Residues}
\label{\detokenize{MMMx_addresses:residues}}
Residues can be addressed either by number or by type. Residue numbers are positive and do not neccessarily agree with the ones in the PDB file. Whether they do, is indicated in field \sphinxcode{\sphinxupquote{original\_residue\_numbers}} at entity level.

Residue types are three\sphinxhyphen{}letter codes for amino acid residues, two\sphinxhyphen{}letter codes for DNA nucleotides, and single\sphinxhyphen{}letter codes for RNA nucleotides. Defined cofactors usually have three\sphinxhyphen{}letter codes. In MMMx as in ChimeraX, residue types are case\sphinxhyphen{}insensitive.

\begin{sphinxadmonition}{note}{Residue address examples}

\sphinxcode{\sphinxupquote{(A)131}}  addresses residue 131 in chain A

\sphinxcode{\sphinxupquote{37\sphinxhyphen{}39,55}} addresses residues 37, 38, 39, and 55 in all chains

\sphinxcode{\sphinxupquote{(C)arg,lys}} addresses all arginine and lysine residues in chain C

\sphinxcode{\sphinxupquote{(B)*}} addresses all residues in chain B
\end{sphinxadmonition}


\section{Atoms}
\label{\detokenize{MMMx_addresses:atoms}}
Atoms can be addressed by type, which is usually a string with up to four characters that must start with a letter.
If an atom name in the original PDB file started with a digit, it is preceded by \sphinxcode{\sphinxupquote{A\_}} in MMMx.
The atom address \sphinxcode{\sphinxupquote{backbone}} selects the \sphinxcode{\sphinxupquote{N}}, \sphinxcode{\sphinxupquote{CA}}, \sphinxcode{\sphinxupquote{C}}, and \sphinxcode{\sphinxupquote{O}} atoms of a peptide residue.
A list of atom addresses starts with a dot \sphinxcode{\sphinxupquote{.}}.

\begin{sphinxadmonition}{note}{Atom address examples}

\sphinxcode{\sphinxupquote{(B)22.CB}}  addresses the \sphinxcode{\sphinxupquote{CB}} atom in residue 22 of chain B

\sphinxcode{\sphinxupquote{.CG1,CG2}} addresses all \sphinxcode{\sphinxupquote{CG1}} and \sphinxcode{\sphinxupquote{CG2}} atoms in the entity

\sphinxcode{\sphinxupquote{(A)128\sphinxhyphen{}135.backbone,CB}} addresses the backbone atoms and the \sphinxcode{\sphinxupquote{CB}} atom in the residue range from 128 to 135 in chain A

\sphinxcode{\sphinxupquote{131.*}} addresses all atoms in residues 131 of all chains
\end{sphinxadmonition}


\section{Water molecules}
\label{\detokenize{MMMx_addresses:water-molecules}}
The address \sphinxcode{\sphinxupquote{water}} can be used to select or unselect all water molecules. Selection of individual water molecules or water atom locations by address is not supported.


\section{Conformers}
\label{\detokenize{MMMx_addresses:conformers}}
Conformers are addressed by numbers in curly brackets \sphinxcode{\sphinxupquote{\{\}}}. By default, conformer 1 (model 1 in PDB) is selected. It is not possible to unselect all conformers.
The selection is empty if no chain, no residue, and no atom is selected. For the conformer range, keywords \sphinxcode{\sphinxupquote{start}} (first conformer) and \sphinxcode{\sphinxupquote{end}} (last conformer) are supported.

\begin{sphinxadmonition}{note}{Conformer address examples}

\sphinxcode{\sphinxupquote{\{3\sphinxhyphen{}5,12\}}}  addresses conformers 3, 4, 5, and 12 of the whole entity

\sphinxcode{\sphinxupquote{\{4\sphinxhyphen{}end\}}} addresses all conformers starting at number 4

\sphinxcode{\sphinxupquote{\{7\}(A).CA}} addresses all \sphinxcode{\sphinxupquote{CA}} atoms of chain A in conformer 7

\sphinxcode{\sphinxupquote{\{5\}cys,met}} addresses all cysteine and methionine residues in conformer 5 of the entity

\sphinxcode{\sphinxupquote{\{*\}}} selects all conformers of the entity
\end{sphinxadmonition}


\section{Rotamers}
\label{\detokenize{MMMx_addresses:rotamers}}
Rotamers are addressed at residue level by their numbers after a vertical bar \sphinxcode{\sphinxupquote{|}}.
By default, rotamer 1 is selected. It is not possible to unselect all rotamers if the residue, the chain, or the conformer is selected.
Rotamer selection overrules location selection for atoms. In a rotameric structure, atom locations correspond to distinct rotamers.

\begin{sphinxadmonition}{note}{Rotamer address examples}

\sphinxcode{\sphinxupquote{(A)131|1\sphinxhyphen{}3}}  addresses rotamers 1, 2, 3 of residue 131 in chain (A)

\sphinxcode{\sphinxupquote{55\sphinxhyphen{}57|2.CA}} addresses the second \sphinxstyleemphasis{location} (where no location tag is often the first location) for the \sphinxcode{\sphinxupquote{CA}} atoms of residues 55, 56, and 57 in all chains

\sphinxcode{\sphinxupquote{gln|2}} addresses the second rotamer for all glutamine residues in the entity

\sphinxcode{\sphinxupquote{glu|*}} addresses all rotamers for all glutamate residues in the entity
\end{sphinxadmonition}


\section{Locations}
\label{\detokenize{MMMx_addresses:locations}}
Locations are addressed at atom level by their tags after a colon \sphinxcode{\sphinxupquote{:}}.
A location tag is preferably a single upper\sphinxhyphen{}case letter for up to 26 locations and a single lower\sphinxhyphen{}case letter for locations 27\sphinxhyphen{}52. More than 52 locations cannot be stored in PDB files.
By default, the first location (location tag is usually a space) is selected. It is not possible to unselect all locations if the atom is selected.
If you want to address a location by its tag, you must not address rotamers in the same address.

\begin{sphinxadmonition}{note}{Location address examples}

\sphinxcode{\sphinxupquote{.OE1:B}}  addresses location B of all OE1 atoms in the entity, if no such location exists for an OE1 atom, the first location is selected

\sphinxcode{\sphinxupquote{(A)glu.OE1:A}} addresses location A of OE1 atoms of all glutamate residues in chain A

\sphinxcode{\sphinxupquote{glu.OE1:*}} addresses all locations of OE1 atoms in all glutamate residues in chain A
\end{sphinxadmonition}


\section{Programmatic access}
\label{\detokenize{MMMx_addresses:programmatic-access}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{entity}\PYG{p}{,}\PYG{n}{exceptions}\PYG{p}{]} \PYG{p}{=} \PYG{n}{select}\PYG{p}{(}\PYG{n}{entity}\PYG{p}{,}\PYG{n}{address}\PYG{p}{,}\PYG{n}{overwrite}\PYG{p}{,}\PYG{n}{unselect}\PYG{p}{)}
\end{sphinxVerbatim}

selects objects by \sphinxcode{\sphinxupquote{address}} in an \sphinxcode{\sphinxupquote{entity}}. If \sphinxcode{\sphinxupquote{overwrite}} (default: false) is true, a pre\sphinxhyphen{}existing selection is deleted.
If \sphinxcode{\sphinxupquote{unselected}} (default: false) is true, the addressed objects are unselected rather than selected. An unselect request overrules a simultaneous overwrite request.
For the address \sphinxcode{\sphinxupquote{selected}}, the value of \sphinxcode{\sphinxupquote{overwrite}} is inconsequential, whereas \sphinxcode{\sphinxupquote{unselect = true}} unselects the existing selection.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{atom\PYGZus{}indices}\PYG{p}{,}\PYG{n}{complete}\PYG{p}{]} \PYG{p}{=} \PYG{n}{get\PYGZus{}selection}\PYG{p}{(}\PYG{n}{entity}\PYG{p}{)}
\end{sphinxVerbatim}

retrives sorted atom indices into the \sphinxcode{\sphinxupquote{.xyz\textasciigrave{}}}, \sphinxcode{\sphinxupquote{.elements}}, and \sphinxcode{\sphinxupquote{.occupancies}}, and \sphinxcode{\sphinxupquote{.index\_array}} fields of \sphinxcode{\sphinxupquote{entity}}.
If requested, \sphinxcode{\sphinxupquote{complete}} returns full indices (chain, residue, atom, conformer, rotamer/location), which are not sorted.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{addresses}\PYG{p}{,}\PYG{n}{exceptions}\PYG{p}{]} \PYG{p}{=} \PYG{n}{cx\PYGZus{}to\PYGZus{}mmmx\PYGZus{}address}\PYG{p}{(}\PYG{n}{spec}\PYG{p}{)}
\end{sphinxVerbatim}

translates the ChimeraX target specification \sphinxcode{\sphinxupquote{spec}} into MMMx addresses (cell array, one entry for each structure identifier in \sphinxcode{\sphinxupquote{spec}}). See below.
Error messages or warnings are reported as MException objects in cell array \sphinxcode{\sphinxupquote{exceptions}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{spec}\PYG{p}{,}\PYG{n}{exceptions}\PYG{p}{]} \PYG{p}{=} \PYG{n}{cx\PYGZus{}from\PYGZus{}mmmx\PYGZus{}address}\PYG{p}{(}\PYG{n}{address}\PYG{p}{,}\PYG{n}{id}\PYG{p}{)}
\end{sphinxVerbatim}

Projects an MMMx \sphinxcode{\sphinxupquote{address}} to a ChimeraX target specification \sphinxcode{\sphinxupquote{spec}} (see below), for which an optional structure identifier \sphinxcode{\sphinxupquote{ìd}} in ChimeraX can be supplied.
Error messages or warnings are reported as MException objects in cell array \sphinxcode{\sphinxupquote{exceptions}}.


\section{Changes compared to MMM}
\label{\detokenize{MMMx_addresses:changes-compared-to-mmm}}
The MMMx address format was designed to be as close as possible to the MMM address format, but allowing for full access to the \sphinxcode{\sphinxupquote{MMMx:atomic}} representation of ensemble structure.
This entailed the following changes:
\begin{itemize}
\item {} 
the structure identifier in square brackets is no longer required, since MMMx methods work on an entity

\item {} 
rotamer addressing was newly introduced

\item {} 
the wildcard is now the asterisk \sphinxcode{\sphinxupquote{*}} rather than the colon \sphinxcode{\sphinxupquote{:}}

\item {} 
preferably, the conformer is now addressed first, whereas MMM addressed it as “chain model” after the chain identifier; both address sequences still work

\end{itemize}


\section{Correspondence with ChimeraX}
\label{\detokenize{MMMx_addresses:correspondence-with-chimerax}}
MMMx can translate a subset of basic ChimeraX target specifications into MMM addresses. The following functionality of ChimeraX target specifications is \sphinxstylestrong{not} translated:
\begin{itemize}
\item {} 
usage of \sphinxcode{\sphinxupquote{start}} and \sphinxcode{\sphinxupquote{end}} in ranges, except for conformers

\item {} 
structure hierarchy with a depth of more than two (only structure and conformers allowed)

\item {} 
ranges for structure identifiers or chain identifiers

\item {} 
implicit operations (returning higher\sphinxhyphen{}level address parts)

\item {} 
use of the wild card \sphinxcode{\sphinxupquote{*}} for part of a name

\item {} 
use of the wild card \sphinxcode{\sphinxupquote{?}} for single characters

\item {} 
built\sphinxhyphen{}in classifications

\item {} 
user\sphinxhyphen{}defned attributes

\item {} 
zones

\item {} 
combinations

\end{itemize}

Such selections can be made in ChimeraX, also via the ChimeraX interface of MMMx, and can then be imported into MMMx.

MMMx can project its own addresses onto ChimeraX target specifications, as far as the ChimeraX target specification supports the type of addressing.
This excludes rotamer and atom location addressing.


\chapter{MMMx|atomic}
\label{\detokenize{MMMx_atomic:mmmx-atomic}}\label{\detokenize{MMMx_atomic:id1}}\label{\detokenize{MMMx_atomic::doc}}

\section{Basic considerations}
\label{\detokenize{MMMx_atomic:basic-considerations}}
From a thermodynamic point of view, different conformers have different probability to occur, as they have different free energies. They should thus be assigned populations.

If modelling is based on restraints in the form of probability density distributions, such as distance distribution restraints, probabilities of conformers are accessible in modelling.

The reason for alternate atom locations in protein crystal structures is, in most cases, significant population of more than one sidechain rotamer.
This should be assigned at residue level, not atom level.

From both a conceptual and data processing point of view, it makes sense to separate topology (fixed and the same for all conformers) from coordinates (variable).

Coordinates are heterogeneously different, meaning that for some atoms they do differ between conformers, while for others they do not.
Especially for large ensembles, it makes sense to store only unique coordinates.

\begin{sphinxadmonition}{note}{Coordinate indices}

An atom coordinate is assigned by five indices. Three are \sphinxstyleemphasis{topological} and designate
\begin{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
the molecule, which can be a macromolecular chain

\item {} 
the residue in a chain

\item {} 
the atom in a residue

\end{enumerate}

The remaining two indices are \sphinxstyleemphasis{conformational} and designate
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\setcounter{enumi}{3}
\item {} 
the conformer

\item {} 
the rotamer of a sidegroup (structures with specified rotamers) or one of the atom locations existing for a residue (crystal structures with locations)

\end{enumerate}
\end{quote}
\end{sphinxadmonition}

The Cartesian coordinate array \(\mathbf{C}\) of an entity is thus supplemented by a coordinate index array \(\mathbf{I}_\mathrm{c}\).
In Matlab, \sphinxhref{https://blogs.mathworks.com/loren/2013/02/20/logical-indexing-multiple-conditions/}{logical indexing}, together with the index array, provides a very intuitive and efficient way for extracting required subsets of coordinates and to reassign them after some processing.
The index array is typed \sphinxcode{\sphinxupquote{uint16}}, so that each hierarchy level can hold up to 65535 items.

The coordinate array is further supplemented by a vector of atomic numbers (number of the element in the periodic table) and by a vector of occupancies. Both vectors are single\sphinxhyphen{}byte unsigned integers. Occupancy is multiplied by 100 and rounded to an integer for storage.


\section{Topology}
\label{\detokenize{MMMx_atomic:topology}}
Topology describes chemical structure and is immutable for an entity. In other words, any chemical reaction, such as posttranslational modification, is a transfer from one entity to another entity.

Topology is represented in terms of the number of objects (chains, molecules, residues, atoms), their identifiers, and their hierarchical relation.
Hierarchical relation means that an atom belongs to a residue or molecule and a residue belongs to a chain. The term \sphinxstyleemphasis{residue} includes amino acid residues, nucleotide residues, and, if someone finds a way to characterize carbohydrates, a sugar residue.

In Matlab, hierarchy is easily represented by a multi\sphinxhyphen{}level structure. By combining this with \sphinxhref{https://ch.mathworks.com/help/matlab/matlab\_prog/generate-field-names-from-variables.html}{dynamic fieldnames}, storage and access become very convenient and efficient.

Further attributes of objects can be stored by extending levels of the topology variable with additional fields.

\begin{sphinxadmonition}{note}{Field name conventions}

All object names start with capital letters. They are:
\begin{quote}
\begin{itemize}
\item {} 
\sphinxstylestrong{Chain identifiers}. Small letters from PDB files with more than 26 chains are represented by a capital letter with an appended underscore.
Entities with more than 26 chains can be exchanged with other software only in \sphinxcode{\sphinxupquote{mmCIF}} format.

\item {} 
\sphinxstylestrong{Residue identifiers}. Capital \sphinxcode{\sphinxupquote{R}} followed by the residue number.

\item {} 
\sphinxstylestrong{Atom identifiers}. The atom name in PDB or mmCIF syntax. Primes are substituted by an underscore.
If a name starting with a lowercase character is encountered, the first letter is capitalized and an underscore is appended to the atom name.

\end{itemize}

The fieldname \sphinxcode{\sphinxupquote{selected}} is reserved at all levels. At entity level it is a vector of selected conformers (default: 1), at other levels a boolean flag.

The fieldname \sphinxcode{\sphinxupquote{index}} is reserved at all levels below entity. This field holds the topology index per object and level.

The fieldnames \sphinxcode{\sphinxupquote{water}} and \sphinxcode{\sphinxupquote{water\_selected}} at entity level are reserved for water molecules. They hold an index vector of all water atoms and a flag whether they are selected.

The fieldnames \sphinxcode{\sphinxupquote{name}}, \sphinxcode{\sphinxupquote{xyz}}, \sphinxcode{\sphinxupquote{index\_array}}, \sphinxcode{\sphinxupquote{elements}}, \sphinxcode{\sphinxupquote{occupancies}}, and \sphinxcode{\sphinxupquote{original\_residue\_numbers}} are reserved at entity level

The fieldname \sphinxcode{\sphinxupquote{populations}} is reserved at entity level and at residue level. At residue level, the length of the population vecor specifies the number of rotamers.

The fieldnames \sphinxcode{\sphinxupquote{name}}, \sphinxcode{\sphinxupquote{selected\_rotamers}}, \sphinxcode{\sphinxupquote{locations}}, \sphinxcode{\sphinxupquote{\textasciigrave{}dssp}}, and \sphinxcode{\sphinxupquote{sheet}} are reserved at residue level

The fieldnames \sphinxcode{\sphinxupquote{element}}, \sphinxcode{\sphinxupquote{selected\_locations}}, \sphinxcode{\sphinxupquote{charge}}, and \sphinxcode{\sphinxupquote{bfactor}} are reserved at atom level

Methods can define further lower\sphinxhyphen{}case fieldnames for object attributes. These attributes are internal to the method.
Passing back such attributes to MMMx and saving them in \sphinxcode{\sphinxupquote{mmCIF}} output files may be enabled in a future release.
\end{quote}
\end{sphinxadmonition}


\section{Conformation}
\label{\detokenize{MMMx_atomic:conformation}}
The only information on conformation that the topology variable needs to hold are population vectors (vide supra) on entity level and on residue level (rotamers).
The length of these vectors specifies the number of entity conformers or sidechain rotamers. The topology variable must also hold the topological indices (vide supra).
With that information, all atom coordinates can be retrieved via the index array from the coordinate array and the associated populations can be computed.


\section{Element assignment of atoms}
\label{\detokenize{MMMx_atomic:element-assignment-of-atoms}}
The information still missing even for basic computations concerns element assignment of the atoms, as retrieval from the atom name is not safe.
For ease of access, this information is stored in a separate element vector that matches the coordinate index array, but can be typed \(int8\).


\section{Conversion to PDB representation}
\label{\detokenize{MMMx_atomic:conversion-to-pdb-representation}}
In the \sphinxcode{\sphinxupquote{MMMx|atomic}} representation, the same atom coordinate can apply in several conformers (\sphinxstyleemphasis{models} in the PDB representation).
Upon conversion to PDB, the coordinate array expands. The PDB writer of MMMx expands per conformer during writing to reduce memory requirements.

Rotameric states are expressed by alternate atom locations. Up to 26 (preferably) or 52 (with lower\sphinxhyphen{}case location identifiers) rotamers can be converted.
Not all external programs may be able to process PDB files with more than 26 locations. By default, only the 26 rotamers with highest populations are converted.
As an option, 52 rotamers can be converted.

If an atom coordinate in the \sphinxcode{\sphinxupquote{MMMx|atomic}} representation is “not a number”, this atom is ignored.
This should happen only if the structure originated from an inconsistent PDB file.

MMMx converts to PDB representation only for two purposes:
\begin{itemize}
\item {} 
saving structure in a PDB files

\item {} 
transmitting structure to ChimeraX for visualization

\end{itemize}


\section{Conversion from PDB representation}
\label{\detokenize{MMMx_atomic:conversion-from-pdb-representation}}
Upon loading a PDB file, MMMx does not make an effort to preserve atom numbers and only a limited effort to preserve residue numbers of the original PDB entry.
Residue numbers are preserved in the about \sphinxhref{http://mmcif.wwpdb.org/dictionaries/mmcif\_pdbx\_v40.dic/Items/\_atom\_site.pdbx\_PDB\_ins\_code.html}{96.5\% structures that do not use “insertion codes”} and only if they all are positive numbers and if, within the same chain, they appear in ascending order in the PDB file.
The entity has a field \sphinxcode{\sphinxupquote{original\_residue\_numbers}} that indicates whether residue numbers were preserved.

The number of chain/molecule conformers equals the number of PDB \sphinxcode{\sphinxupquote{models}} for all chains and molecules of the entity. Uniform populations are assumed.

The number of rotamers of a residue is as large as the maximum number of alternate locations among the atoms of this residue.
Rotamer populations are mean populations over all atoms which have this number of alternate locations.

In case of topological inconsistency between \sphinxstyleemphasis{models}, topology is determined by the first model encountered in the PDB file (regardless of its model number).
Only atom coordinates are read for further models. Surplus atom coordinates are ignored. Missing atom coordinates are assigned “not a number”.


\chapter{MMMx|RigiFlex}
\label{\detokenize{MMMx_RigiFlex:mmmx-rigiflex}}\label{\detokenize{MMMx_RigiFlex:id1}}\label{\detokenize{MMMx_RigiFlex::doc}}

\section{Basic considerations}
\label{\detokenize{MMMx_RigiFlex:basic-considerations}}
Quite a few proteins contain \sphinxstyleemphasis{Anfinsen domains} that are ordered on the length scale of a fraction of a bond length. Usually these are small globular domains.

Representing such proteins in the \(PDB\) or \(MMMx|atomic\) format has two disadvantages
\begin{itemize}
\item {} 
information on rigid\sphinxhyphen{}body character of these domains is lost

\item {} 
in large ensembles, unneccessary storage of many coordinates related by the same translation and rotation is wasteful

\end{itemize}

As MMMx creates \sphinxstyleemphasis{RigiFlex} ensemble structures, where chains can be rigid bodies joint
by flexible linkers and rigid\sphinxhyphen{}body arrangement within a chain or between chains can be distributed, it makes sense to have a special representation.


\section{Format}
\label{\detokenize{MMMx_RigiFlex:format}}
Flexible sections are treated as in the \(MMMx|atomic\) format.

Each rigid body has its separate coordinate array, corresponding to its \sphinxstyleemphasis{reference position and orientation}.
In Matlab, these arrays are organized in a cell vector, which is a field \(rigidbodies\) of the entity variable.

Rigid bodies can be named. For this, there is a cell vector of strings \(rigidbody\_names\) at entity level.

The topology variable has an additional field \(rigidbody\) at residue level. The value is zero for residues in flexible sections.
Otherwise, it is the number of the rigid body, which is also the index into the cell vectors \(rigidbodies\) and \(rigidbody\_names\).

The rigid\sphinxhyphen{}body arrangement information stored at entity level in a field \(rba\).
For an entity with \(c\) conformers, \(rba\) is a \(c \times 6\) array \([\Delta x, \Delta y, \Delta z, \alpha, \beta, \gamma]\)
where \(\Delta x\), \(\Delta y\), and \(\Delta z\) are Cartesian translations (in Angstroems) and \(\alpha\), \(\beta\), and \(\gamma\) are Euler angles (\(zyz\) convention) in radians.


\section{Conversion to MMMx|atomic representation}
\label{\detokenize{MMMx_RigiFlex:conversion-to-mmmx-atomic-representation}}
In order to avoid information loss, the RigiFlex representation is converted to the atomic representation only on two occasions
\begin{itemize}
\item {} 
a method that can only process the atomic representation requests the entity

\item {} 
a PDB representation is required for file saving or transmission to ChimeraX

\end{itemize}

In the latter case, the MMMx|atomic representation is only used in further expansion to the PDB representation.

Expansion from \(MMMx|RigiFlex\) to \(MMMx|atomic\) explicitly creates the atom coordinates for all rigid\sphinxhyphen{}body arrangements,
appends them to coordinate array \(\mathbf{C}\) and correspondingly amends the index array \(\mathbf{I}_\mathrm{c}\).

The fields \(rigidbodies\) and \(rigidbody\_names\) at entity level and \(rigidbody\) at residue level are removed only upon request.
They allow for later back conversion, if, to a sufficiently good approximation, the domains moved as rigid bodies during
processing by the method that requested the atomic representation.


\chapter{Object access}
\label{\detokenize{object_access:object-access}}\label{\detokenize{object_access:id1}}\label{\detokenize{object_access::doc}}

\section{Concept}
\label{\detokenize{object_access:concept}}
Object access functions return or set object attributes, where an object is a conformer, a chain, a residue, a rotamer, an atom, or an atom location.
They operate on an \sphinxcode{\sphinxupquote{entity}}, which is an MMMx ensemble structure representation in {\hyperref[\detokenize{MMMx_atomic:mmmx-atomic}]{\sphinxcrossref{\DUrole{std,std-ref}{MMMx|atomic}}}} or {\hyperref[\detokenize{MMMx_RigiFlex:mmmx-rigiflex}]{\sphinxcrossref{\DUrole{std,std-ref}{MMMx|RigiFlex}}}} format.

Wherever possible, methods should operate on an entity only through object access functions. In order to speed up access to coordinates,
an additional function \sphinxcode{\sphinxupquote{get\_coor}} exists for retrieving atom coordinates and corresponding indices for objects and combinations of objects selected on any level of structural hierachy.
The pendant \sphinxcode{\sphinxupquote{set\_coor}} uses the indices returned by \sphinxcode{\sphinxupquote{get\_coor}} for reassignment of processed coordinates.

\sphinxcode{\sphinxupquote{get}} functions retrieve attributes, whereas \sphinxcode{\sphinxupquote{set}} functions set or change attributes. They are specific to an object hierarchy level in order to avoid unintended behaviour.
The objects are selected by an {\hyperref[\detokenize{MMMx_addresses:mmmx-addresses}]{\sphinxcrossref{\DUrole{std,std-ref}{MMMx address}}}}. The address can also be \sphinxcode{\sphinxupquote{selected}} for accessing all currently selected objects on this hierarchy level.


\section{Generic syntax}
\label{\detokenize{object_access:generic-syntax}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{argout}\PYG{p}{,}\PYG{n}{exceptions}\PYG{p}{]} \PYG{p}{=} \PYG{n}{get\PYGZus{}}\PYG{l+s}{\PYGZdq{}object\PYGZdq{}}\PYG{p}{(}\PYG{n}{entity}\PYG{p}{,}\PYG{n}{address}\PYG{p}{,}\PYG{n}{attribute}\PYG{p}{)}
\end{sphinxVerbatim}

where possible \sphinxcode{\sphinxupquote{attribute}} strings are specific to the “object” hierarchy level (“conformer”, “chain”, “residue”, “rotamer”, “atom”, “location”, see below) and argout is a cell vector, whose length is the number of objects of this hierarchy level that were selected by \sphinxcode{\sphinxupquote{address}}.
Error messages or warnings are reported as MException objects in cell array \sphinxcode{\sphinxupquote{exceptions}}.


\section{Residues}
\label{\detokenize{object_access:residues}}
Residues can be addressed either by number or by type. Residue numbers are positive and do not neccessarily agree with the ones in the PDB file. Whether they do, is indicated in field \sphinxcode{\sphinxupquote{original\_residue\_numbers}} at entity level.

Residue types are three\sphinxhyphen{}letter codes for amino acid residues, two\sphinxhyphen{}letter codes for DNA nucleotides, and single\sphinxhyphen{}letter codes for RNA nucleotides. Defined cofactors usually have three\sphinxhyphen{}letter codes. In MMMx as in ChimeraX, residue types are case\sphinxhyphen{}insensitive.

\begin{sphinxadmonition}{note}{Residue address examples}

\sphinxcode{\sphinxupquote{(A)131}}  addresses residue 131 in chain A

\sphinxcode{\sphinxupquote{37\sphinxhyphen{}39,55}} addresses residues 37, 38, 39, and 55 in all chains

\sphinxcode{\sphinxupquote{(C)arg,lys}} addresses all arginine and lysine residues in chain C

\sphinxcode{\sphinxupquote{(B)*}} addresses all residues in chain B
\end{sphinxadmonition}


\section{Atoms}
\label{\detokenize{object_access:atoms}}
Atoms can be addressed by type, which is usually a string with up to four characters that must start with a letter.
If an atom name in the original PDB file started with a digit, it is preceded by \sphinxcode{\sphinxupquote{A\_}} in MMMx.
The atom address \sphinxcode{\sphinxupquote{backbone}} selects the \sphinxcode{\sphinxupquote{N}}, \sphinxcode{\sphinxupquote{CA}}, \sphinxcode{\sphinxupquote{C}}, and \sphinxcode{\sphinxupquote{O}} atoms of a peptide residue.
A list of atom addresses starts with a dot \sphinxcode{\sphinxupquote{.}}.

\begin{sphinxadmonition}{note}{Atom address examples}

\sphinxcode{\sphinxupquote{(B)22.CB}}  addresses the \sphinxcode{\sphinxupquote{CB}} atom in residue 22 of chain B

\sphinxcode{\sphinxupquote{.CG1,CG2}} addresses all \sphinxcode{\sphinxupquote{CG1}} and \sphinxcode{\sphinxupquote{CG2}} atoms in the entity

\sphinxcode{\sphinxupquote{(A)128\sphinxhyphen{}135.backbone,CB}} addresses the backbone atoms and the \sphinxcode{\sphinxupquote{CB}} atom in the residue range from 128 to 135 in chain A

\sphinxcode{\sphinxupquote{131.*}} addresses all atoms in residues 131 of all chains
\end{sphinxadmonition}


\section{Water molecules}
\label{\detokenize{object_access:water-molecules}}
The address \sphinxcode{\sphinxupquote{water}} can be used to select or unselect all water molecules. Selection of individual water molecules or water atom locations by address is not supported.


\section{Conformers}
\label{\detokenize{object_access:conformers}}
Conformers are addressed by numbers in curly brackets \sphinxcode{\sphinxupquote{\{\}}}. By default, conformer 1 (model 1 in PDB) is selected. It is not possible to unselect all conformers.
The selection is empty if no chain, no residue, and no atom is selected. For the conformer range, keywords \sphinxcode{\sphinxupquote{start}} (first conformer) and \sphinxcode{\sphinxupquote{end}} (last conformer) are supported.

\begin{sphinxadmonition}{note}{Conformer address examples}

\sphinxcode{\sphinxupquote{\{3\sphinxhyphen{}5,12\}}}  addresses conformers 3, 4, 5, and 12 of the whole entity

\sphinxcode{\sphinxupquote{\{4\sphinxhyphen{}end\}}} addresses all conformers starting at number 4

\sphinxcode{\sphinxupquote{\{7\}(A).CA}} addresses all \sphinxcode{\sphinxupquote{CA}} atoms of chain A in conformer 7

\sphinxcode{\sphinxupquote{\{5\}cys,met}} addresses all cysteine and methionine residues in conformer 5 of the entity

\sphinxcode{\sphinxupquote{\{*\}}} selects all conformers of the entity
\end{sphinxadmonition}


\section{Rotamers}
\label{\detokenize{object_access:rotamers}}
Rotamers are addressed at residue level by their numbers after a vertical bar \sphinxcode{\sphinxupquote{|}}.
By default, rotamer 1 is selected. It is not possible to unselect all rotamers if the residue, the chain, or the conformer is selected.
Rotamer selection overrules location selection for atoms. In a rotameric structure, atom locations correspond to distinct rotamers.

\begin{sphinxadmonition}{note}{Rotamer address examples}

\sphinxcode{\sphinxupquote{(A)131|1\sphinxhyphen{}3}}  addresses rotamers 1, 2, 3 of residue 131 in chain (A)

\sphinxcode{\sphinxupquote{55\sphinxhyphen{}57|2.CA}} addresses the second \sphinxstyleemphasis{location} (where no location tag is often the first location) for the \sphinxcode{\sphinxupquote{CA}} atoms of residues 55, 56, and 57 in all chains

\sphinxcode{\sphinxupquote{gln|2}} addresses the second rotamer for all glutamine residues in the entity

\sphinxcode{\sphinxupquote{glu|*}} addresses all rotamers for all glutamate residues in the entity
\end{sphinxadmonition}


\section{Locations}
\label{\detokenize{object_access:locations}}
Locations are addressed at atom level by their tags after a colon \sphinxcode{\sphinxupquote{:}}.
A location tag is preferably a single upper\sphinxhyphen{}case letter for up to 26 locations and a single lower\sphinxhyphen{}case letter for locations 27\sphinxhyphen{}52. More than 52 locations cannot be stored in PDB files.
By default, the first location (location tag is usually a space) is selected. It is not possible to unselect all locations if the atom is selected.
If you want to address a location by its tag, you must not address rotamers in the same address.

\begin{sphinxadmonition}{note}{Location address examples}

\sphinxcode{\sphinxupquote{.OE1:B}}  addresses location B of all OE1 atoms in the entity, if no such location exists for an OE1 atom, the first location is selected

\sphinxcode{\sphinxupquote{(A)glu.OE1:A}} addresses location A of OE1 atoms of all glutamate residues in chain A

\sphinxcode{\sphinxupquote{glu.OE1:*}} addresses all locations of OE1 atoms in all glutamate residues in chain A
\end{sphinxadmonition}


\section{Programmatic access}
\label{\detokenize{object_access:programmatic-access}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{entity}\PYG{p}{,}\PYG{n}{exceptions}\PYG{p}{]} \PYG{p}{=} \PYG{n}{select}\PYG{p}{(}\PYG{n}{entity}\PYG{p}{,}\PYG{n}{address}\PYG{p}{,}\PYG{n}{overwrite}\PYG{p}{,}\PYG{n}{unselect}\PYG{p}{)}
\end{sphinxVerbatim}

selects objects by \sphinxcode{\sphinxupquote{address}} in an \sphinxcode{\sphinxupquote{entity}}. If \sphinxcode{\sphinxupquote{overwrite}} (default: false) is true, a pre\sphinxhyphen{}existing selection is deleted.
If \sphinxcode{\sphinxupquote{unselected}} (default: false) is true, the addressed objects are unselected rather than selected. An unselect request overrules a simultaneous overwrite request.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{atom\PYGZus{}indices}\PYG{p}{,}\PYG{n}{complete}\PYG{p}{]} \PYG{p}{=} \PYG{n}{get\PYGZus{}selection}\PYG{p}{(}\PYG{n}{entity}\PYG{p}{)}
\end{sphinxVerbatim}

retrives sorted atom indices into the \sphinxcode{\sphinxupquote{.xyz\textasciigrave{}}}, \sphinxcode{\sphinxupquote{.elements}}, and \sphinxcode{\sphinxupquote{.occupancies}}, and \sphinxcode{\sphinxupquote{.index\_array}} fields of \sphinxcode{\sphinxupquote{entity}}.
If requested, \sphinxcode{\sphinxupquote{complete}} returns full indices (chain, residue, atom, conformer, rotamer/location), which are not sorted.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{addresses}\PYG{p}{,}\PYG{n}{exceptions}\PYG{p}{]} \PYG{p}{=} \PYG{n}{cx\PYGZus{}to\PYGZus{}mmmx\PYGZus{}address}\PYG{p}{(}\PYG{n}{spec}\PYG{p}{)}
\end{sphinxVerbatim}

translates the ChimeraX target specification \sphinxcode{\sphinxupquote{spec}} into MMMx addresses (cell array, one entry for each structure identifier in \sphinxcode{\sphinxupquote{spec}}). See below.
Error messages or warnings are reported as MException objects in cell array \sphinxcode{\sphinxupquote{exceptions}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{spec}\PYG{p}{,}\PYG{n}{exceptions}\PYG{p}{]} \PYG{p}{=} \PYG{n}{cx\PYGZus{}from\PYGZus{}mmmx\PYGZus{}address}\PYG{p}{(}\PYG{n}{address}\PYG{p}{,}\PYG{n}{id}\PYG{p}{)}
\end{sphinxVerbatim}

Projects an MMMx \sphinxcode{\sphinxupquote{address}} to a ChimeraX target specification \sphinxcode{\sphinxupquote{spec}} (see below), for which an optional structure identifier \sphinxcode{\sphinxupquote{ìd}} in ChimeraX can be supplied.
Error messages or warnings are reported as MException objects in cell array \sphinxcode{\sphinxupquote{exceptions}}.


\section{Changes compared to MMM}
\label{\detokenize{object_access:changes-compared-to-mmm}}
The MMMx address format was designed to be as close as possible to the MMM address format, but allowing for full access to the \sphinxcode{\sphinxupquote{MMMx:atomic}} representation of ensemble structure.
This entailed the following changes:
\begin{itemize}
\item {} 
the structure identifier in square brackets is no longer required, since MMMx methods work on an entity

\item {} 
rotamer addressing was newly introduced

\item {} 
the wildcard is now the asterisk \sphinxcode{\sphinxupquote{*}} rather than the colon \sphinxcode{\sphinxupquote{:}}

\item {} 
preferably, the conformer is now addressed first, whereas MMM addressed it as “chain model” after the chain identifier; both address sequences still work

\end{itemize}


\section{Correspondence with ChimeraX}
\label{\detokenize{object_access:correspondence-with-chimerax}}
MMMx can translate a subset of basic ChimeraX target specifications into MMM addresses. The following functionality of ChimeraX target specifications is \sphinxstylestrong{not} translated:
\begin{itemize}
\item {} 
usage of \sphinxcode{\sphinxupquote{start}} and \sphinxcode{\sphinxupquote{end}} in ranges, except for conformers

\item {} 
structure hierarchy with a depth of more than two (only structure and conformers allowed)

\item {} 
ranges for structure identifiers or chain identifiers

\item {} 
implicit operations (returning higher\sphinxhyphen{}level address parts)

\item {} 
use of the wild card \sphinxcode{\sphinxupquote{*}} for part of a name

\item {} 
use of the wild card \sphinxcode{\sphinxupquote{?}} for single characters

\item {} 
built\sphinxhyphen{}in classifications

\item {} 
user\sphinxhyphen{}defned attributes

\item {} 
zones

\item {} 
combinations

\end{itemize}

Such selections can be made in ChimeraX, also via the ChimeraX interface of MMMx, and can then be imported into MMMx.

MMMx can project its own addresses onto ChimeraX target specifications, as far as the ChimeraX target specification supports the type of addressing.
This excludes rotamer and atom location addressing.


\chapter{ChimeraX}
\label{\detokenize{ChimeraX:chimerax}}\label{\detokenize{ChimeraX::doc}}
MMMx communicates with ChimeraX for visualization. MMMx can use ChimeraX for PDB and mmCIF file loading and saving, for retrieving information on an entity, for entity building, and entity modification.

The graphical user interfaces (GUIs) of ChimeraX and MMMx can be used simultaneously.
As ChimeraX is the more powerful GUI, it holds the master copy of the entity. MMMx retrieves the entity from ChimeraX before applying a method.
For MMMx methods that potentially change the entity, MMMx then deletes the entity in ChimeraX, and resubmits the entity to ChimeraX after the method has completed.
\begin{itemize}
\item {} \begin{description}
\item[{Communication protocol}] \leavevmode
MMMx uses REST (representational state transfer) remote control both for setting states of ChimeraX and for polling ChimeraX for information:
\begin{itemize}
\item {} 
ChimeraX needs to call the command \sphinxcode{\sphinxupquote{remotecontrol rest start port 51051}} upon startup

\item {} 
communication depends on log response of ChimeraX commands

\item {} 
MMMx claims the name of entities (models) that it loads into ChimeraX

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Using MMMx without ChimeraX}] \leavevmode
MMMx can be used standalone, including its own GUI, but the following restrictions apply:
\begin{itemize}
\item {} 
no 3D structure visualization

\item {} 
only structure information is read from and written to PDB files

\item {} 
no mmCIF support

\item {} 
selection is only by commands and supports only the selection modes of MMM

\item {} 
for methods that require secondary structure analysis, DSSP must be installed and registered

\end{itemize}

\end{description}

\end{itemize}


\bigskip\hrule\bigskip



\section{Remarks}
\label{\detokenize{ChimeraX:remarks}}\begin{itemize}
\item {} 
The startup commands can be set in ChimeraX via the menu item \sphinxcode{\sphinxupquote{Favorites\textbackslash{}Settings...}} after navigating to tab \sphinxcode{\sphinxupquote{Startup}}.

\item {} 
The log response of ChimeraX is very well structured, but we are not guarded against future format changes

\item {} 
MMMx models in ChimeraX have unique names MMMx\_*mmmid*, where \sphinxstyleemphasis{mmmid} is the internal identifier in MMMx
This guards against accidental replacement of an MMMx model by another model by the user.
The other model could then have the same number, but would not have the MMMx name.

\item {} 
If ChimeraX is running and connected, MMMx accesses DSSP secondary structure analysis through ChimeraX

\item {} 
Methods can specify what information they need on an entity. Only this information is polled from ChimeraX.

\end{itemize}


\chapter{Python}
\label{\detokenize{python:python}}\label{\detokenize{python::doc}}
MMMx could be implemented in Matlab, in Python, or as a mixture of both.

Here are some advantages and disadvantages of using Python:
\begin{itemize}
\item {} 
Advantages
\begin{itemize}
\item {} 
larger potential programmer base

\item {} 
larger base of existing bioinformatics modules

\item {} 
clean syntax

\item {} 
automated documentation is easier

\item {} 
fully open source

\end{itemize}

\item {} 
Disadvantages
\begin{itemize}
\item {} 
data types are not as good as in Matlab

\item {} 
documentation is very heterogeneous across packages

\item {} 
hard to keep consistent, while packages evolve

\item {} 
lower programming productivity

\item {} 
much overhead bt discussions, which packages should or should not be used

\item {} 
porting existing MMM functions is not generally trivial (data typing)

\item {} 
once, everybody programmed Java, now everybody programs Python, will it be Julia tomorrow?

\end{itemize}

\end{itemize}


\bigskip\hrule\bigskip



\section{Remarks}
\label{\detokenize{python:remarks}}\begin{itemize}
\item {} 
After looking more closely into the language, I am astonished what people can do with it despite its design.

\item {} 
The syntax is nice and reads well.

\item {} 
With \sphinxcode{\sphinxupquote{numpy}}, Python is well suited to numerical data processing.

\item {} 
String processing is much better supported in Matlab since 2018

\item {} 
Compilers have gone out of business, a non\sphinxhyphen{}backwards compatible change of the language has been done, there are plans for further changes

\item {} 
quality and generality of existing modules is very heterogeneous

\item {} 
many larger projects tend to use Python only as a layer above a C++ core

\end{itemize}


\section{Current conclusion}
\label{\detokenize{python:current-conclusion}}
MMMx should be able to integrate methods programmed in Python. These methods can be supplied with \sphinxstyleemphasis{entities}, \sphinxstyleemphasis{rotamer libraries}, \sphinxstyleemphasis{distance distribution restraints}, and \sphinxstyleemphasis{restraint files} by MMMx.

A full port of MMM to Python would delay the first version of MMMx by years.


\chapter{Dependencies}
\label{\detokenize{dependencies:dependencies}}\label{\detokenize{dependencies::doc}}
MMMx is self\sphinxhyphen{}contained in the following two modes:
\begin{itemize}
\item {} 
structure analysis, modification, and generation with scripting (MMMx GUI not required)

\item {} 
structure analysis, modification, and generation from the MMMx GUI without 3D molecule visualization

\end{itemize}

There are three caveats:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
methods that require DSSP depend on either a DSSP standalone or ChimeraX access

\item {} 
methods that generate or optimize sidechains depend on SCWRL4

\item {} 
automated structure refinement requires a Yasara structure license

\end{enumerate}

For 3D molecular visualization, MMMx depends on ChimeraX. ChimeraX can also be used for accessing information beyond entity structure from PDB or mmCIF files.

Methods should not directly access ChimeraX. They operate on an entity and can define, in comments or by an auxiliary function, what information beyond structure they request.

\sphinxstylestrong{File name convention}: All functions that access ChimeraX have a function name starting with \sphinxcode{\sphinxupquote{cx\_}}.


\chapter{Concept}
\label{\detokenize{concept:concept}}\label{\detokenize{concept::doc}}
MMMx relies on well designed and well maintained software for standard tasks.

It is intended for modelling structure of proteins and their complexes and for supporting label\sphinxhyphen{}based spectroscopic techniques, such as EPR, FRET and NMR techniques that use spin labels.
\begin{itemize}
\item {} \begin{description}
\item[{Imports}] \leavevmode
Imports are functionalities that MMMx sources from external apps or packages:
\begin{itemize}
\item {} 
Protein and nucleic acid structure loading, saving, manipulation and visualization by \sphinxstyleemphasis{ChimeraX}

\item {} 
Small\sphinxhyphen{}angle scattering curve simulation and fitting by the \sphinxstyleemphasis{ATSAS} package

\item {} 
Amino acid side chain generation or optimization by \sphinxstyleemphasis{SCWRL4}

\item {} 
Sequence alignment by \sphinxstyleemphasis{MUSCLE}

\item {} 
Structure refinement by \sphinxstyleemphasis{Yasara}

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Exports}] \leavevmode
Exports are functionalities that MMMx provides by building or processing structure data:
\begin{itemize}
\item {} 
Spin label and chromophore modelling via rotamer libraries

\item {} 
Simulation of distance distributions between labels

\item {} 
Localization of labels at structurally unresolved sites with espect to a structure

\item {} 
Conformational transitions by distance\sphinxhyphen{}restraint based deformation of elastic network models

\item {} 
Ensemble modelling of flexible peptide and RNA chains or chain segments

\item {} 
RigiFlex ensemble models based on distributed rigid\sphinxhyphen{}body arrangement and flexible segments

\end{itemize}

\end{description}

\end{itemize}


\bigskip\hrule\bigskip



\section{Open source concept}
\label{\detokenize{concept:open-source-concept}}
All MMMx functions and definitions are open source. However, MMMx may rely for some of its functionality on external apps that are not open source or not even free (Yasara for structure refinement is an example).


\section{Separation of user interface from computation}
\label{\detokenize{concept:separation-of-user-interface-from-computation}}
The graphical user interface (GUI) of MMMx coordinates the work of MMMx methods and functionalities of external apps and visualizes numerical data.

MMMx methods can be called from scripts without running the GUI and without reliance on ChimeraX. For that, MMMx has basic PDB file read and write facility.


\section{Visibility to users and programmers}
\label{\detokenize{concept:visibility-to-users-and-programmers}}
Although MMMx is open source, users and programmers need to be aware that implementation details can change without notice.

Only part of MMMx functionality can reliably be used in scripts, contributed methods, or by external requests:
\begin{itemize}
\item {} \begin{description}
\item[{Data}] \leavevmode
The following types of data have a stable, though extensible definition:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{entity}: internal representation of macromolecular (ensemble) structure

\item {} 
\sphinxstyleemphasis{rotlib}: rotamer library

\item {} 
\sphinxstyleemphasis{ddr}: distance distribution restraint

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Functionality}] \leavevmode
The following elements of MMMx functionality will be stable, though extensible:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Commands}: allow for control and scripting in the MMMx GUI

\item {} 
\sphinxstyleemphasis{Methods}: build, modify or analyze an entity

\item {} 
\sphinxstyleemphasis{Restraint file}: specify experimental restraints and methods that operate on them

\end{itemize}

\end{description}

\end{itemize}


\chapter{Data}
\label{\detokenize{data:data}}\label{\detokenize{data::doc}}

\section{Entity}
\label{\detokenize{data:entity}}
An \sphinxstyleemphasis{entity} holds the structure information on a protein, a nucleic acid molecule, or complexes thereof, possibly including small\sphinxhyphen{}molecule ligands and water molecules.

The entity consists of several \sphinxstyleemphasis{conformers} for an ensemble structure. Conformers have the same primary structure (amino acid or nucleotide sequence), but can differ in secondary, tertiary, and quaternary structure.

Each atom has a unique address and, in general, Cartesian coordinates (in Angstroem). Cartesian coordinates can be unspecified (“not a number”).

\begin{sphinxadmonition}{note}{Addresses}

The atom address for specifying the CA atom of residue 131 in conformer 1 of chain A in structure 2LZM is \sphinxstylestrong{\textasciigrave{}\textasciigrave{}{[}2LZM{]}(A)\{1\}131.CA\textasciigrave{}\textasciigrave{}} in MMM. In ChimeraX, it is \sphinxstylestrong{\textasciigrave{}\textasciigrave{}\#1/A:131@CA\textasciigrave{}\textasciigrave{}}. The user must know that structure 2LZM is model \#1.
\end{sphinxadmonition}

Methods can operate on the coordinates, which are hold in one common array for each conformer of a chain. Methods can also change residues and thus sequence in a chain (mutation). For any changes beyond that, a new entity should be derived.

\begin{sphinxadmonition}{note}{Matlab realization}

In Matlab, an entity is described by data type \sphinxcode{\sphinxupquote{struct}} with dynamic field names. Field names that begin with a capital letter describe primary structure (chain identifiers, residue numbers, conformer numbers, atom identifiers). Field names that begin with a lower\sphinxhyphen{}case letter provide additional information, such as coordinates, residue names, the element, etc.
\end{sphinxadmonition}

The MMMx entity file format is based on this extensible Matlab structure variable. Extension is by \sphinxstyleemphasis{attributes}. Each level (entity, chain, residue, conformer, atom) can have additional attributes, whose lower\sphinxhyphen{}case names are dynamical field names in Matlab.


\section{Rotamer library}
\label{\detokenize{data:rotamer-library}}
A rotamer library contains sidechain conformers for a spin label or chromophore label, together with their populations in the absence of interactions with a macromolecule.

Further \sphinxstyleemphasis{attributes} specify the attachment frame (by three atoms), the label position and possibly the label orientation. They may also provide information on how the library was generated.

Representation in Matlab and as MMMx file format is analogous to an \sphinxstyleemphasis{entity}.


\section{Distance distribution restraints}
\label{\detokenize{data:distance-distribution-restraints}}
Distance distribution restraints are specified at least by a distance axis (in Angstroem) and probabilities that a distance falls into a given bin on the diatance axis. The sum of all probabilities is unity.

Further, optional attributes are lower and upper probability bounds, a handle to a function that generates a parametric distance distribution, and parameter values and uncertainties.


\chapter{Documentation}
\label{\detokenize{docs:documentation}}\label{\detokenize{docs::doc}}

\section{Concept}
\label{\detokenize{docs:concept}}
MMMx documentation will be handled with Sphinx. The main documentation channel is HTML, i.e., the \sphinxcode{\sphinxupquote{.rst}} source files will be optimized for HTML appearance.
Still, a PDF version via Latex will be made available.

The documentation is organized as follows:
\begin{itemize}
\item {} \begin{description}
\item[{User part}] \leavevmode
Everything needed for users without scripting and programming ambitions:
\begin{itemize}
\item {} 
introduction to the purpose of MMMx and its structure representation

\item {} 
graphical user interface (MMMx Control GUI)

\item {} 
command reference

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Programmer part}] \leavevmode
Everything needed for programmatic access, external access, and contributing to MMMx:
\begin{itemize}
\item {} 
introduction to scripting

\item {} 
function reference

\item {} 
external interface (if developed)

\end{itemize}

\end{description}

\end{itemize}

An external interface would be implemented as a \sphinxhref{https://ch.mathworks.com/help/thingspeak/rest-api.html}{REST API}.


\section{Automation}
\label{\detokenize{docs:automation}}
The following aspects will be automated in order to keep MMMx documentation and package consistent:
\begin{itemize}
\item {} 
basic description of GUI windows

\item {} 
command reference

\item {} 
function reference

\end{itemize}

For these cases, the documentation source are comment sections in the code source files. Compilation of the documentation has two steps:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
extraction of the information from the code source files into \sphinxcode{\sphinxupquote{.rst}} source files

\item {} 
building the HTML (and Latex) files with the \sphinxcode{\sphinxupquote{make}} command of Sphinx

\end{enumerate}

For Python code, the first step is done by the \sphinxcode{\sphinxupquote{autodoc}} feature of Sphinx. For Matlab code, this will be done by a Matlab function.



\renewcommand{\indexname}{Index}
\printindex
\end{document}
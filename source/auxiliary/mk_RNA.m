function [ecoor,atomtags,code] = mk_RNA(fragments,seq,code,nct,ntoffset,transmat)
% function [ecoor,atomtags,code] = mk_RNA(fragments,seq,code,nct,ntoffset,transmat)
%
% Generates an RNA chain by random selection of conformers from a fragment
% library, 
% see also E. Humphris-Narayanan, A. M. Pyle, J. Mol. Biol. 2012, 421, 6-26
%
% fragments     fragment library, as generated by recompile_library.m
% seq           sequence in single letter code, allowed nucleotides A,C,G,U
%               must be at least two nucleotides long
% code          vector of fragment numbers in the library, same length as
%               seq, if not given, a random fragment number sequence is
%               generated
% nct           table of non-clashing pairs, as generated by
%               find_non_clshing.m, if given, clashes between immediate
%               neighbor residues are automatically avoided
% ntoffset      optional offset for nucleotide number, defaults to 0
% transmat      affine transformation matrix for coordinates, defaults to
%               unity matrix
%
% ecoor         [poi+2,4] matrix of extended coordinates of poi+2 atoms
%               the last two atoms are the P and C4' atom of a hypothetical
%               next residue, which are required for chain prolongation by
%               the same algorithm
%               column 1: residue number
%               columns 2-4: Cartesian coordinates
% atomtags      cell string of PDB atom tags (length poi+2)
% code          vector of fragment numbers in the library, same length as
%               seq
%
% G. Jeschke, 26.12.2017

if ~exist('transmat','var')
    transmat = eye(4);
end

if ~exist('ntoffset','var')
    ntoffset = 0;
end

slc = 'ACGU';

maxat = 23; % maximum number of atoms of a nucleotide

clash_threshold = 1.5; % minimum distance between atoms in non-consecutive residues

if ~exist('code','var') || isempty(code)
    randomized = true;
else
    randomized = false;
end

if ~exist('nct','var') || isempty(nct)
    clash_test = false;
else
    clash_test = true;
end

nl = length(fragments);
atomtags = cell(1,maxat*length(seq)+2);
ecoor = zeros(maxat*length(seq)+2,4);
poi = 0;

base = upper(seq(1));
bcode = zeros(1,length(seq));
bcode(1) = strfind(slc,base);

if randomized
    code = zeros(1,length(seq));
    code(1) = 1 + floor(nl*rand-eps);
end

fragment = fragments(code(1)).(base);
[m,~] = size(fragment.coor);
coor = fragment.coor(2:end,:);
ecoor(poi+1:poi+m-3,1) = ntoffset; % number zero corresponds to initial anchor
ecoor(poi+1:poi+m-1,2:4) = coor;
atomtags(poi+1:poi+m-3) = fragment.atomtags(2:end-2);
C4pprev = fragment.assign.next(1) - 1; % first atom has been removed
poi = poi + m-3;
for k = 2:length(seq)
    base = upper(seq(k));
    if randomized
        if clash_test
            bcode(k) = strfind(slc,base);
            pair = 4*(bcode(k-1)-1) + bcode(k);
            non_clash_table = nct{pair};
            non_clashing = non_clash_table{code(k-1)};
            code_pointer = 1 + floor(length(non_clashing)*rand-eps);
            code(k) = non_clashing(code_pointer);
        else
            code(k) = 1 + floor(nl*rand-eps);
        end
    end
    fragment = fragments(code(k)).(base);
    [m,~] = size(fragment.coor);
    coor1 = [ecoor(C4pprev,2:4);...
        ecoor(poi+1,2:4);...
        ecoor(poi+2,2:4)];
    [Rp,orig] = get_trafo(coor1);
    fcoor = [fragment.coor(fragment.assign.previous(1),:);...
        fragment.coor(fragment.assign.previous(2),:);...
        fragment.coor(fragment.assign.previous(3),:)];
    [Rpf,origf] = get_trafo(fcoor);
    coor2 = fragment.coor(2:end,:) - repmat(origf,m-1,1);
    Rp2 = Rpf'*Rp;
    coor2 = coor2*Rp2 + repmat(orig,m-1,1);
    ecoor(poi+1:poi+m-3,1) = k + ntoffset -1;
    ecoor(poi+1:poi+m-1,2:4) = coor2;
    pair_dist = get_all_pair_dist(ecoor(1:poi,2:4),coor2(2:m-3,:));
    midi1 = min(pair_dist);
    min_dist = min(midi1);
    if min_dist < clash_threshold
        % fprintf(1,'Clash at distance %4.2f Å between %i:%s and %i:%s\n',min_dist,ecoor(mip1(mip2),1),atomtags{mip1(mip2)},k+ntoffset-1,fragment.atomtags{2+mip2});
        ecoor = [];
        code = [];
        atomtags = {};
        return
    end
    atomtags(poi+1:poi+m-3) = fragment.atomtags(2:end-2);
    C4pprev = poi + fragment.assign.next(1) - 1;
    poi = poi + m-3;
end
ecoor = ecoor(1:poi,:);
atomtags = atomtags(1:poi);

[m,~] = size(ecoor);
fcoor = [ecoor(:,2:4) ones(m,1)];
fcoor = fcoor*transmat';
ecoor(:,2:4) = fcoor(:,1:3);

function [Rp,orig] = get_trafo(coor)

orig = coor(2,:);
coor = coor - repmat(orig,3,1);
x = coor(1,:)-coor(2,:); 
x = x/norm(x);    % unit vector along x
yp = coor(3,:)-coor(2,:); 
yp = yp/norm(yp);
z = cross_rowvec(x,yp); % z axis is perpendicular on xy plane
z = z/norm(z);
y = cross_rowvec(z,x); % real (corrected) y axis
Rp = [x;y;z];

function c=cross_rowvec(a,b)
% A fast cross product that works only for two three-element row vectors 

c = [a(2)*b(3)-a(3)*b(2),a(3)*b(1)-a(1)*b(3),a(1)*b(2)-a(2)*b(1)];

function pair_dist = get_all_pair_dist(a,b)

[m1,~] = size(a); % get sizes of the coordinates arrays
[m2,~] = size(b);

a2 = repmat(sum(a.^2,2),1,m2);
b2 = repmat(sum(b.^2,2),1,m1).';
pair_dist = sqrt(abs(a2 + b2 - 2*a*b.'));


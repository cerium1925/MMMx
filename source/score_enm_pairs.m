function [entity,pairs] = score_enm_pairs(entity,sites,labels,fname,r_min,r_max)
% shortlist = SCORE_ENM_PAIRS(entity,pairs,labels,fname,maxn)
%
% scores site pairs by their suitability for driving state transitions with
% energy equipartitioning to normal modes of an elastic network model
%
% Input:
%
% entity    MMMx:atomic entity of the structure
% sites     list of labeling site pairs as generated by site_scan.m
% labels    cell string{1,2} of label identifiers for first/second site in
%           each pair 
% fname     file name for the output (scored pair list)
% r_min     minimum label-to-label mean distance, defaults to 15 Angstroem
% r_max     maximum label-to-label mean distance, defaults to 80 Angstroem
%
% Output:
%
% entity    entity, possibly with added label rotamers
% pairs     pair list struct with added field .score, sorted increasing
%           mode frequency, if unsuccessful, .score is not added and file
%           is not written

% This file is a part of MMMx. License is MIT (see LICENSE.md). 
% Copyright(c) 2021: Gunnar Jeschke

if ~exist('r_min','var')
    r_min = 15;
end
if ~exist('r_max','var')
    r_max = 80;
end

% make the elastic network model
CA_model = get_CA_model(entity); % extract the Calpha model, conformer 1 assumed, if there are several
Hessian = get_ANM_Hessian(CA_model);

if isempty(Hessian)
    return
end

% diagonalize the Hessian
[u,~] = eig(Hessian);
[m,~] = size(Hessian);

% determine network indices of sites

ms = length(sites);
mn = length(CA_model.addresses);
correspondence=zeros(1,ms); % correspondence table between sites and network nodes

network0 = CA_model.coor;
labels0 = zeros(size(network0));

mask = zeros(1,m/3);
back_corr = zeros(1,m/3);
for ks = 1:ms
    [~,site_adr] = split_conformer_site(sites(ks).address);
    for kn = 1:mn
        node_adr = CA_model.addresses{kn};
        if strcmp(site_adr,node_adr)
            correspondence(ks) = kn;
            back_corr(kn) = ks;
            mask(kn) = 1;
            break
        end
    end
end

mask(1:2)=0;
mask(end-1:end)=0;
mmask=kron(mask,mask');

% determine distances and their standard deviations for all pairs
dmatrix = zeros(ms,ms);
large_dmatrix = zeros(m/3,m/3);
large_smatrix = zeros(m/3,m/3);

for ks1 = 1:ms-1
    [entity,NO_mean] = mean_label_coor(entity,sites(ks1).address,labels{1});
    if isempty(NO_mean)
        continue
    end
    i1 = correspondence(ks1);
    labels0(i1,:) = NO_mean;
    for ks2 = ks1+1:ms
        [r_axis,distribution,entity] = distance_distribution(entity,...
            sites(ks1).address,labels{1},sites(ks2).address,labels{2});
        if isempty(distribution)
            continue;
        end
        distribution = distribution/sum(distribution);
        rmean = sum(r_axis.*distribution);
        if rmean < r_min
            continue;
        end
        if rmean > r_max
            continue;
        end
        Delta_r = r_axis - rmean;
        sigr = sqrt(sum(distribution.*Delta_r.^2));
        dmatrix(ks1,ks2) = rmean;
        dmatrix(ks2,ks1) = sigr;
        i2 = correspondence(ks2);
        large_dmatrix(i1,i2) = rmean;
        large_dmatrix(i2,i1) = rmean;
        large_smatrix(i1,i2) = sigr;
        large_smatrix(i2,i1) = sigr;
    end
end

mmask = mmask.*(large_dmatrix ~= 0);

maxn = length(sites)*(length(sites)-1)/2;
if maxn > m - 6
    maxn = m-6;
end
pairs(maxn).address1 = '';
pairs(maxn).address2 = '';
pairs(maxn).nr1 = 0;
pairs(maxn).nr2 = 0;
pairs(maxn).r_mean = 0;
pairs(maxn).r_std = 0;
pairs(maxn).score = 0;

poi=0;
dmat0 = coor2dmat(labels0); % label-to-label distance matrix for initial structure
for k= 7:6+maxn
    evec = u(:,k);
    mode = reshape(evec,3,m/3);
    network = network0 + mode'; % network change by move along this mode
    dmat = label_dmat(network0,network,labels0,mask,CA_model,back_corr); % corresponding label-to-label-distance matrix
    dmat1 = dmat-dmat0; % distance change matrix
    dmat = abs(dmat1).*mmask; % mask all pairs that should not be selected at all
    for k0=1:poi % mask all pairs that were selected before and very close pairs
        k1 = correspondence(pairs(k0).nr1);
        k2 = correspondence(pairs(k0).nr2);
        dmat(k1-2:k1+2,k2-2:k2+2) = 0;
        dmat(k2-2:k2+2,k1-2:k1+2) = 0;
    end
    [ma,k0] = max(dmat); % determine node pair that corresponds to 
    [ma2,k2] = max(ma);   % maximum distance change for this mode
    if ma2 < 10*eps
        break
    end
    k1 = k0(k2);
    poi = poi+1;
    pairs(poi).score = abs(dmat1(k1,k2));
    pairs(poi).nr1 = back_corr(k1); % assign
    pairs(poi).nr2 = back_corr(k2);
    pairs(poi).r_mean = large_dmatrix(k1,k2);
    pairs(poi).r_std = large_smatrix(k1,k2);
end

pairs = pairs(1:poi);
for k = 1:poi
    pairs(k).address1 = sites(pairs(k).nr1).address;
    pairs(k).address2 = sites(pairs(k).nr2).address;
end

m = length(pairs);
fid = fopen(fname,'wt');
fprintf(fid,'%% MMMx ENM-optimal site pair list for labels: %s|%s\n',labels{1},labels{2});
fprintf(fid,'%% %i pairs were found for energy equipartitioning.\n',m);
fprintf(fid,'%% Site1            Site2     rmean (%s)  sigr (%s)    score\n',char(197),char(197));

for k = 1:m
    site1 = pairs(k).address1;
    site2_str = pad(pairs(k).address2,24-length(site1),'left');
    fprintf(fid,'%s%s%14.1f%10.1f%10.3f\n',site1,site2_str,pairs(k).r_mean,pairs(k).r_std,pairs(k).score);
end
fclose(fid);

function [c,site] = split_conformer_site(address)
% retrieves conformer number from site address

c = 1;
site = address;
pa = strfind(address,'{');
pe = strfind(address,'}');
if ~isempty(pa) && ~isempty(pe)
    c = str2double(address(pa+1:pe-1));
    if pa > 1
        pre = address(1:pa-1);
    else
        pre = '';
    end
    if pe < length(address)
        past = address(pe+1:end);
    else
        past = '';
    end
    site = [pre past];
end

function [entity,NO_mean] = mean_label_coor(entity,site,label)

NO_mean = [];
[argsout,entity,exceptions] = get_label(entity,label,{'positions','populations','part_fun'},site);
if ~isempty(exceptions{1})
    return
end
positions = argsout{1}{1};
populations = argsout{2}{1};
populations = populations/sum(populations);
NO_mean = populations'*positions;

function dmat = label_dmat(network0,network,labels0,mask,CA_model,back_corr)

[maxnum,~] = size(network);
labels1 = zeros(size(labels0));
% update of label coordinates
for k = 1:maxnum
    if mask(k) % this network node has a label attached
        local_template = zeros(5,3);
        local_template_0 = zeros(5,3);
        ind1 = get_residue_number(CA_model.addresses{k});
        % make a local template to fit rotation and translation
        poi=0;
        for kk = -2:2
            ind2 = get_residue_number(CA_model.addresses{k+kk});
            if k+kk > 0 && k+kk <= maxnum % is addressed residue a network point?
                diff = ind2-ind1;
                if diff == kk % is addressed residue part of a continuous segment?
                    poi=poi+1;
                    local_template(poi,:) = network(k+kk,:);
                    local_template_0(poi,:) = network0(k+kk,:);
                end
            end
        end
        if poi >= 3 % found sufficient number of points to determine local rotation and translation
            [~,~,transmat] = rmsd_superimpose(local_template(1:poi,:),local_template_0(1:poi,:));
            xyz = [labels0(back_corr(k),:) 1];
            xyz = transmat*xyz';
            xyz = xyz';
            labels1(k,:) = xyz(1:3);
        else
            labels1(k,:) = xyz + network(k,:)-network0(k,:);
        end
    end
end

dmat = coor2dmat(labels1); % corresponding distance matrix 

function num = get_residue_number(address)

poi = strfind(address,')');
if isempty(poi)
    poi = 0;
end
num = str2double(address(poi+1:end));

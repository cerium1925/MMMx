function [entity,exceptions,failed] = module_enm(control,logfid,entity)
%
% MODULE_ENM Runs elastic network modeling of a conformation transition
%
%   [entity,exceptions] = MODULE_ENM(control,logfid,entity)
%   Given a template conformer (entity), an ensemble of target conformers
%   is generated by deforming an elastic network model. The target 
%   conformers fulfill given distance restraints. Supports only peptide
%   chains.
%
% INPUT
% control       control structure with fields
%               .name           'enm', unused
%               .options        options struct
%               .directives     array of struct with directives
%               .entity_output  number of the entity to be output
% logfid        file handle for log file, defaults to console output
% entity        input entity, defines rigid-body coordinates, must exist
%
% OUTPUT
% entity        output entity
% exceptions    cell vector of MException objects if something went wrong, 
%               defaults to one cell holding an empty array
% failed        flag indicating whether the module failed
%
% SUPPORTED DIRECTIVES
%
% getpdb        load PDB file as template entity
% ensemble      number of target conformers in a thermal ensemble
% remove        removes a residue from the input entity
% chains        chains in the input entity that should be included in the
%               model, defaults to all chains
% save          basis file name for saving target conformers
%               defaults to 'MMMx_enm_transition'
% ddr           distance distribution restraints
% drag          specifies residues that are not part of a peptide chain,
%               but should be dragged along with the closest C_alpha atoms,
%               only one drag block is allowed
% conformer     use a certain conformer (MODEL) of an PDB ensemble file as
%               template, defaults to 1 (first or only model in PDB file) 
%

% This file is a part of MMMx. License is MIT (see LICENSE.md). 
% Copyright(c) 2021: Gunnar Jeschke

% initialize empty output
exceptions = {[]};
warnings = 0;
failed = false;


% set defaults

min_lambda = 1e3*eps; % minimum frequency of a non-degenerate mode

save_name = 'MMMx_enm_transition'; % default name for saving output entity

restraints.p_model = 0.5;
restraints.uncertainty = 3;
restraints.ensemble = 100;

if ~isempty(control.options)
    restraints.p_model = str2double(control.options{1});
end

if isempty(logfid)
    logfid = 1;
end


restraints.ddr(1).labels{1} = '';
restraints.drag{1} = '';
restraints.chains = '*';
restraints.conformer = 1;

ddr_poi = 0;
drag_poi = 0;
rm_poi = 0;
removal = cell(1,100);
% read restraints
for d = 1:length(control.directives)
    switch lower(control.directives(d).name)
        case 'getpdb'
            entity = get_pdb(control.directives(d).options{1});
        case 'getalphafold'
            entity = get_AF(control.directives(d).options{1});
        case 'save'
            save_name = control.directives(d).options{1};
        case 'remove'
            rm_poi = rm_poi + 1;
            removal{rm_poi} = control.directives(d).options{1};
        case 'ensemble'
            restraints.ensemble = str2double(control.directives(d).options{1});
            if length(control.directives(d).options) >= 2
                restraints.uncertainty = str2double(control.directives(d).options{2});
            end
        case 'conformer'
            restraints.conformer = round(str2double(control.directives(d).options{1}));
        case 'chains'
            chains = char(zeros(1,length(control.directives(d).options)));
            for k = 1:length(control.directives(d).options)
                chains(k) = control.directives(d).options{k}(1);
            end
            restraints.chains = chains;
        case 'ddr'
            ddr_poi = ddr_poi + 1; % increase ddr block counter
            fprintf(logfid,'ddr %s',control.directives(d).options{1}); % echo directive to log file
            restraints.ddr(ddr_poi).labels{1} = control.directives(d).options{1};
            if length(control.directives(d).options) > 1 % different labels
                restraints.ddr(ddr_poi).labels{2} = control.directives(d).options{2};
                fprintf(logfid,' %s\n',control.directives(d).options{2});
            else % same label at both sites
                restraints.ddr(ddr_poi).labels{2} = control.directives(d).options{1};
                fprintf(logfid,'\n');
            end
            [nr,args] = size(control.directives(d).block);
            if nr > 0 % at least one restraint in this block
                restraints.ddr(ddr_poi).site1{nr} = ' ';
                restraints.ddr(ddr_poi).site2{nr} = ' ';
                restraints.ddr(ddr_poi).r(nr) = 0;
                restraints.ddr(ddr_poi).sigr(nr) = 0;
                restraints.ddr(ddr_poi).file{nr} = '*';
            else % empty block
                warnings = warnings + 1;
                exceptions{warnings} = MException('module_enm:empty_ddr_block', 'ddr block %i is empty',d);
                record_exception(exceptions{warnings},logfid);
            end
            if args < 3 % misformed restraint line
                warnings = warnings + 1;
                exceptions{warnings} = MException('module_enm:misformed_ddr', 'ddr restraint has less than three arguments');
                record_exception(exceptions{warnings},logfid);
                failed = true;
                return
            end
            for kr = 1:nr
                restraints.ddr(ddr_poi).site1{kr} = control.directives(d).block{kr,1};
                restraints.ddr(ddr_poi).site2{kr} = control.directives(d).block{kr,2};
                restraints.ddr(ddr_poi).file{kr} = '';
                arg3 = control.directives(d).block{kr,3};
                if arg3(1) == '@'
                    restraints.ddr(ddr_poi).file{kr} = arg3(2:end);
                    restraints.ddr(ddr_poi).r(kr) = NaN;
                    restraints.ddr(ddr_poi).sigr(kr) = NaN;
                else
                    restraints.ddr(ddr_poi).r(kr) = str2double(arg3);
                    restraints.ddr(ddr_poi).sigr(kr) = str2double(control.directives(d).block{kr,4});
                end
                if args > 4
                    arg5 = control.directives(d).block{kr,5};
                    if ~isempty(arg5) && arg5(1) == '@'
                        restraints.ddr(ddr_poi).file{kr} = arg5(2:end);
                    end
                end
                for karg = 1:args
                    fprintf(logfid,'  %s',control.directives(d).block{kr,karg});
                end
                fprintf(logfid,'\n');
            end
            fprintf(logfid,'\n\n');
        case 'drag'
            [nd,~] = size(control.directives(d).block);
            % extract chains, residues, maximum distances
            for kd = 1:nd
                drag_poi = drag_poi + 1;
                restraints.drag{kd} = control.directives(d).block{kd,1};
            end
        otherwise
            warnings = warnings + 1;
            exceptions{warnings} = MException('module_enm:unknown_directive',...
                'directive %s is unknown',lower(control.directives(d).name));
            record_exception(exceptions{warnings},logfid);

    end
end

for k = 1:rm_poi
    [ctag,rtag] = split_address(removal{k});
    entity.(ctag) = rmfield(entity.(ctag),rtag);
end

[spath,sfile,~] = fileparts(save_name);
save_name = fullfile(spath,sfile);

% if requested, restrict template entity to selected chains
if ~strcmp(restraints.chains,'*')
    for k = 1:length(restraints.chains)
        address = sprintf('(%s)',restraints.chains(k));
        if k == 1
            % overwrite old selection in entity, if any
            [entity,exceptions] = select(entity,address,true);
        else
            [entity,exceptions] = select(entity,address);
        end
    end
    options.selected = true;
    options.bfactor = true;
    options.pdbid = entity.name(1:4);
    put_pdb(entity,sprintf('%s_template.pdb',save_name),options);
    % reload template PDB, a bit inefficient, but safe
    entity = get_pdb(sprintf('%s_template.pdb',save_name));
end

% find and store mean spin label coordinates for distance distribution
% restraints
for kr = 1:length(restraints.ddr)
    for nr = 1:length(restraints.ddr(kr).site1)
        [argsout,entity] = get_label(entity,restraints.ddr(kr).labels{1},'positions',restraints.ddr(kr).site1{nr});
        if isempty(argsout)
            warnings = warnings + 1;
            exceptions{warnings} = MException('module_enm:labeling_site_missing',...
                'ERROR: Labeling site %s missing or cannot be labelled (Aborting)',restraints.ddr(kr).site1{nr});
            record_exception(exceptions{warnings},logfid);
            failed = true;
            return
        end
        positions = argsout{1};
        [argsout,entity] = get_label(entity,restraints.ddr(kr).labels{1},'populations',restraints.ddr(kr).site1{nr});
        if isempty(argsout) || isempty(positions) || isempty(argsout{1})
            warnings = warnings + 1;
            exceptions{warnings} = MException('module_enm:site_cannot_be_labelled',...
                'ERROR: Labeling site %s exists, but cannot be labelled (Aborting)',restraints.ddr(kr).site1{nr});
            record_exception(exceptions{warnings},logfid);
            failed = true;
            return
        end
        populations = argsout{1};
        populations = populations/sum(populations);
        coor1 = populations'*positions;
        [argsout,entity] = get_label(entity,restraints.ddr(kr).labels{2},'positions',restraints.ddr(kr).site2{nr});
        if isempty(argsout)
            warnings = warnings + 1;
            exceptions{warnings} = MException('module_enm:labeling_site_missing',...
                'ERROR: Labeling site %s missing or cannot be labelled (Aborting)',restraints.ddr(kr).site2{nr});
            record_exception(exceptions{warnings},logfid);
            failed = true;
            return
        end
        positions = argsout{1};
        [argsout,entity] = get_label(entity,restraints.ddr(kr).labels{2},'populations',restraints.ddr(kr).site2{nr});
        if isempty(argsout) || isempty(positions) || isempty(argsout{1})
            warnings = warnings + 1;
            exceptions{warnings} = MException('module_enm:site_cannot_be_labelled',...
                'ERROR: Labeling site %s exists, but cannot be labelled (Aborting)',restraints.ddr(kr).site2{nr});
            record_exception(exceptions{warnings},logfid);
            failed = true;
            return
        end
        populations = argsout{1};
        populations = populations/sum(populations);
        coor2 = populations'*positions;
        restraints.ddr(kr).coor{nr} = [coor1; coor2];
        if ~isempty(restraints.ddr(kr).file{nr}) % if a distribution file exists, load distribution
            exp_data = load_distance_distribution(restraints.ddr(kr).file{nr});
            rax = exp_data(:,1)';
            restraints.ddr(kr).rax{nr} = rax; 
            distr = exp_data(:,2)';
            distr = distr/sum(distr);
            restraints.ddr(kr).distr{nr} = distr;
            % set mean distance and standard deviation, if not provided
            if isnan(restraints.ddr(kr).r(nr))
                rmean = sum(rax.*distr);
                restraints.ddr(kr).r(nr) = rmean;
                restraints.ddr(kr).sigr(nr) = sqrt(sum(distr.*(rax-rmean).^2));
            end
        else % if not provided, make distributions
            rax = 0:0.05:restraints.ddr(kr).r(nr)+3*restraints.ddr(kr).sigr(nr);
            distr = exp(-(rax-restraints.ddr(kr).r(nr)).^2/(2*restraints.ddr(kr).sigr(nr)^2));
            distr = distr/sum(distr);
            restraints.ddr(kr).rax{nr} = rax;
            restraints.ddr(kr).distr{nr} = distr;
        end
    end
end

% make the elastic network model
CA_model = get_CA_model(entity,restraints.conformer); % extract the Calpha model, conformer 1 assumed unless specified otherwise
Hessian = get_ANM_Hessian(CA_model);
ENM_param = get_ENM;

if isempty(Hessian)
    warnings = warnings + 1;
    exceptions{warnings} = MException('module_enm:Hessian_unconnected',...
        'The Hessian of the elastic network model is unconnected');
    record_exception(exceptions{warnings},logfid);
    failed = true;
    return
end

% diagonalize the Hessian
[u,D] = eig(Hessian);
lambda = diag(D);
clear D
[m,~] = size(Hessian);
ANM.u = u;
clear u
ANM.lambda = lambda;
ANM.residues = m/3;
ANM.contacts = [];
msf = zeros(1,m/3);
suspicious = zeros(1,m);
suspicious(1:6) = ones(1,6);
% check for suspicious modes (one node moves more than three times as much as all others) 
for k = 7:m % the first six eigenvectors are translation and rotation
    if lambda(k) > min_lambda % consider eigenvector above a eigenvalue threshold min_lambda
        mode = reshape(ANM.u(:,k),3,m/3);
        msf0 = sum(mode.^2,1);
        [ma,poi] = max(abs(msf0));
        msf1 = msf0;
        msf1(poi) = 0;
        ma2 = max(abs(msf1));
        if ma2 > ma/3
            msf = msf + msf0/lambda(k);
        else
            suspicious(k)=1;
        end
    end
end
ANM.msf = msf;
ANM.suspicious = suspicious;
ANM.degenerate = sum(lambda <= min_lambda);

ANM.nu = sqrt(lambda(7:end)); % mode frequencies
inv_nu = ones(size(ANM.nu))./ANM.nu;
inv_nu = inv_nu/inv_nu(1);
ANM.inv_nu = inv_nu; % normalized inverted frequencies
[~,maxbas] = min(abs(inv_nu - ENM_param.tif));
ANM.maxbas = maxbas; % maximum basis size
fprintf(logfid,'%i modes contribute with >= %4.1f%% weighting of slowest mode.\n',ANM.maxbas,100*ENM_param.tif);


% the following implements the default fit mode of MMM 
ENM_param.diagonalize = true;
ENM_param.reorientate = false;
ENM_param.fix_local = 0;

network0 = CA_model.coor;
esize = restraints.ensemble;

% process the distance distribution restraints
[ddr,cancelled] = process_ddr_restraints(entity,restraints,CA_model);

if cancelled
    warnings = warnings + 1;
    exceptions{warnings} = MException('module_enm:no_restraints',...
        'Distance distribution restraints missing or could not be processed');
    record_exception(exceptions{warnings},logfid);
    failed = true;
    return
end

options.maxbas = ANM.maxbas;
options.sat_cycle = ENM_param.mmax;
options.overfit = false;
options.interactive = true;

figure(1); clf;

mb = ANM.maxbas;
if mb < ENM_param.fit_basis
    mb = ENM_param.fit_basis;
end
fprintf(logfid,'Active space extension from %i to %i modes in %i iterations.\n',ENM_param.fit_basis,mb,options.sat_cycle);

ddr0 = ddr;
colors = parula(esize);
max_rmsd = 0;
max_it = 0;
for k = 1:esize % loop for generating an ensemble
    if esize > 1 % add random deviations to distance constraints
        for kd = 1:length(ddr)
            ddr(kd).r = ddr0(kd).r + ddr0(kd).sigr*randn;
        end
    end
    options.color = colors(k,:);
    [~,~,network,~,~,diagnostics] = fit_by_ANM_thermal(network0,ddr,options,CA_model,ENM_param);
    if diagnostics.drmsd0 > max_rmsd
        max_rmsd = diagnostics.drmsd0;
    end
    if diagnostics.numit > max_it
        max_it = diagnostics.numit;
    end
    fprintf(logfid,'\nElastic network fit %i\n',k);
    fprintf(logfid,'   Initial restraint rmsd: %4.1f %s\n',diagnostics.drmsd0,char(197));
    fprintf(logfid,'   Final restraint rmsd  : %4.1f %s after %i iterations\n',diagnostics.drmsd,char(197),diagnostics.converged);
    fprintf(logfid,'   A total of %i iterations took %5.1f s\n',diagnostics.numit,diagnostics.runtime);
    if diagnostics.timeout
        fprintf(logfid,'   ### Fitting was stopped by timeout ###\n');
    end
    if diagnostics.maxit
        fprintf(logfid,'   ### Fitting was stopped by reaching maximum number of iterations ###\n');
    end
    CA_model1 = CA_model;
    CA_model1.coor = network;
    entity1 = transform_structure(entity,CA_model,network,restraints.drag);
    saveopt.pdbid = 'ENMT';
    put_pdb(entity1,sprintf('%s_m%i.pdb',save_name,k),saveopt);    
end
axis([0,max_it,0,1.05*max_rmsd]);
fprintf(logfid,'\n');

function record_exception(exception,logfid)

fprintf(logfid,'### enm exception: %s ###\n',exception.message);

function [ddr,cancelled] = process_ddr_restraints(entity,restraints,CA_model)

cancelled=false;

if ~isfield(restraints,'ddr')
    ddr = [];
    cancelled = true;
    return;
end

ddr_poi = 0;
ddr(1).r = [];
for kblock = 1:length(restraints.ddr)
    label1 = restraints.ddr(kblock).labels{1};
    if contains(label1,'atom')
        type1 = 2;
    else
        type1 = 1;
    end
    label2 = restraints.ddr(kblock).labels{2};
    if contains(label2,'atom')
        type2 = 2;
    else
        type2 = 1;
    end
    for kr = 1:length(restraints.ddr(kblock).site1)
        ddr_poi = ddr_poi + 1;
        ddr(ddr_poi).r = restraints.ddr(kblock).r(kr); %#ok<AGROW>
        ddr(ddr_poi).sigr = restraints.ddr(kblock).sigr(kr); %#ok<AGROW>
        adr1 = restraints.ddr(kblock).site1{kr};
        ddr(ddr_poi).adr1 = adr1; %#ok<AGROW>
        ddr(ddr_poi).xyz1 = restraints.ddr(kblock).coor{kr}(1,:); %#ok<AGROW>
        adr2 = restraints.ddr(kblock).site2{kr};
        ddr(ddr_poi).adr2 = adr2; %#ok<AGROW>
        ddr(ddr_poi).xyz2 = restraints.ddr(kblock).coor{kr}(2,:); %#ok<AGROW>
        % determine the reference residues for moving the label
        coor1 = ddr(ddr_poi).xyz1; % by default use label coordinate
        if type1 == 1 % if this is a spin-labelled residue
            % try to get Calpha atom coordinates of the same residue
            argout = get_atom(entity,'xyz',sprintf('%s.CA',adr1));
            if ~isempty(argout) && ~isempty(argout{1})
                coor1 = argout{1};
            end
        end
        diff = sum((CA_model.coor - coor1).^2,2);
        [~,index] = min(diff);
        ddr(ddr_poi).index1 = index; %#ok<AGROW>
        coor2 = ddr(ddr_poi).xyz2; % by default use label coordinate
        if type2 == 1 % if this is a spin-labelled residue
            % try to get Calpha atom coordinates of the same residue
            argout = get_atom(entity,'xyz',sprintf('%s.CA',adr2));
            if ~isempty(argout) && ~isempty(argout{1})
                coor2 = argout{1};
            end
        end
        diff = sum((CA_model.coor - coor2).^2,2);
        [~,index] = min(diff);
        ddr(ddr_poi).index2 = index; %#ok<AGROW>
    end
end

function [ctag,rtag] = split_address(address)

p1 = strfind(address,'(');
p2 = strfind(address,')');
ctag = address(p1+1:p2-1);
rtag = strcat('R',address(p2+1:end));

